




# TIL 2025_12_18


## 1. Today I Learned (핵심 개념)

## 1. 기본 자료형 소개_Fundamental Data Types


```C++
#include <iostream>

int main()
{
	using namespace std;

	bool bValue = false;
	char chValue = 65;
	float fValue = 3.141592f;
	double dValue = 3.141592;

	int i = (int)3.1415; // copy initialization
	int a((int)3.14); // direct initialization 
	int b{ 4 }; // uniform initialization 

	int k = 0, l = (456), m = { 123 };

	return 0;
}


// cout << (bValue ? 1 : 0) << endl;  

// cout << sizeof(aValue) << endl;
// cout << sizeof(aValue2) << endl;

// cout << sizeof(bValue) << endl;
// cout << sizeof(bool) << endl;

// auto aValue = 3.141592;
// auto aValue2 = 3.141592f;

```

#### Character types

문자 하나를 저장하는 타입

wchar은 윈도우와 리눅스와 왔다 갔다 하는 경우에 골치 아프게 나타나는 경우가 있다
특히 Windows API로 프로그래밍 했을 경우 많이 보게 되는데 최근에는 많이 사라지고 있는 경향이다
많이 쓰진 않지만 이런게 있나 보다 하고 넘어가면 된다
문자를 저장하는 방식 자체가 다른 것들과 조금 다르다
잘못하면 문제가 생길 수도 있다는 것을 알아두면 좋음

#### Integer types

문자 여러 개를 저장하는 것, 문장을 저장하는 것, 단어나 문장 등 메모리를 길게 잡아야 할 때 문자 열을 저장하는 타입

최근 C++에서는 string을 많이 사용한다
string은 fundamental data type은 아니다 근데 사람들이 많이 쓰기 떄문에 표준처럼 마치 기본 데이터 타입인 것처럼 사용되는 경향이 있다
String은 표준 라이브러리라고 일단 알아두자


> [!NOTE] 참고
> Signed int는 음의 정수, 0, 양의 정수(자연수)를, unsigned int는 양의 정수와 0을 포함한다
> 수학 용어에서 '양의 정수(positive integer)'나 '음의 정수(negative integer)'는 0을 포함하지 않음


###### Signed

음수가 가능한 데이터 타입은 signed
음의 정수, 영, 양의 정수 자연수 등을 말함


###### Unsigned

0은 가능한데 음의 정수는 불가능하다


###### Q. 왜 이 차이를 두는것인가?

Singed와 Unsigned하고 저장되는 방식이 다르다
그래서 나중에 for 반복문 이런거 할 때 unsigned가 특정 연산을 할 때는 더 빠른 경우가 있다
똑같이 일을 더 하는데 unsigned가 signed보다 더 빠르다던지, 빼기를 할 때 더 빠르다던지 이런 특징이 있어서 unsigned를 구분했다

즉, 둘 다 정수 타입인데 Signed와 Unsigned는 다르다

그러면 다음과 같이 나온다
이거는 cout에서 자리수를 맞춰줘서 이렇게 나오게 된다

내부적으로는 3.141592를 가장 정확하게 표현할 수 있는 이진수 표현법
이진수로 실수를 표현하는 법으로 바꿔서 저장을 하고 있다

 여기서 중요한건 수학적으로 접근하는 것만큼 정밀하지 않다
 굉장히 큰 오류가 발생할 수 있기 때문이다

#### Q. float에서 f를 빼면 어떻게 되는지?


이 리터럴은 double이다
컴파일러가 3.141592가 인식할때는 double이다 f가 안붙었기 때문이다

근데 Double은 Float보다 메모리를 두 배 쓴다 더 정밀한 것이다
정밀한 것을 정밀도가 떨어지는 Float에다 저장을 하려니까 잘려나가는 부분이 있을 것이다

 truncation, truncate 이게 길면 긴 부분 자른다는 이야기이다, 절삭된다는 의미

그러니 정밀도가 더 높은걸 더 작은 것에다 억지로 스쳐 넣었으니 잘려 나간 부분이 있을 것이다
그러니 감수해라 라고 경고를 해주는 것이다


#### auto value

자동으로 float인지 double인지 구별해서 출력해주는 방식



---


## 2. 정수형 (Integers)


```c++
#include <iostream>
#include <cmath>
#include <limits>

int main()
{
	using namespace std;

	// int i = 22 / 4;

	cout << 22 / (float)4 << endl;

	return 0;
}


// int		i = 1;
// long	l = 1;
// long long ll = 1;

// cout << sizeof(int) << endl;
// cout << sizeof(long) << endl;
// cout << sizeof(long long) << endl;



	// short	s = 1; // 2 bytes = 2 * 8 bits = 16 bits

	//cout << std::pow(2, sizeof(short) * 8 - 1) - 1 << endl;
	//cout << std::numeric_limits<short>::max() << endl;
	//cout << std::numeric_limits<short>::min() << endl;
	//cout << std::numeric_limits<short>::lowest() << endl;

	//s = std::numeric_limits<short>::min();

	//cout << "min() " << s << endl;

	//s = s - 1; 

	//cout << " " << s << endl; // overflow 



	//unsigned int i = -1;

	//cout << i << endl;

```

#### 오버플로우

이게 무슨 현상이냐면 32768이 지금 표현할 수 있는 가장 큰 숫자였다
그래서 2를더하면 그 이진수로 표현을 할 때 표현을 해놓고 2를 더해버리면 뒤로 돌아가버린다
그래서 오히려 더 작은 수가 되어버린 것이다

내생각 : 아 그니까 32768에서 뒤로 가버리니까 -32768이 나오는 논리인 것 같다

그러면 이번에는 가장 작은 숫자에서 1을 빼보자

```C++
#include <iostream>
#include <cmath>
#include <limits>

int main()
{
	using namespace std;

	short	s = 1; // 2 bytes = 2 * 8 bits = 16 bits

	//cout << std::pow(2, sizeof(short) * 8 - 1) - 1 << endl;
	//cout << std::numeric_limits<short>::max() << endl;
	//cout << std::numeric_limits<short>::min() << endl;
	//cout << std::numeric_limits<short>::lowest() << endl;

	s = std::numeric_limits<short>::min();

	cout << "min() " << s << endl;

	s = s - 1; 

	cout << " " << s << endl; // overflow 

	return 0;
}
```

이렇게 수정했다
이렇게 되면 s에 출력이 되는 것은 Min 값일 것이다
short data type이 표현할 수 있는 가장 작은 숫자일 것이다

s에 뭐가 나오는지 확인해보자

```
min() -32768
 32767
```

이렇게 나왔다

-32768에서 -1을 하면 -32769가 나와야 하는데, 32767이 나왔다

다시 이제 돌아가버린 것이다
뱀 두마리가 서로 꼬리를 물고 있는 그런 느낌인 셈이다

이게 굉장히 중요한 문제이다
의외로 많이 만나게 되는 문제이다

오버플로우라고 부르고, 아주 흔하다


---


```C++
#include <iostream>
#include <cmath>
#include <limits>

int main()
{
	using namespace std;

	unsigned int i = -1;

	cout << i << endl;

	return 0;
}
```

unsigned int i에 -1을 넣었다
이렇게 하면 뭐가 나올까?

```
4294967295
```


0이면 좋겠지만 엉뚱한 숫자가 나오게 된다

여기서 문제는 컴파일러가 오류를 안 내준다 Warning도 안내준다

c+의 장점이자 위험한 부분이 여기서 나타나는데 -1은 signed integer type이다
이 -1을 unsigned integer로 자동으로 바꿔줘버린다

근데, 여기서 생각할 때 -1이 표현이 안되면 0으로 바꿔주지 않을까 라는 느낌이 있을 수 있다
근데 컴퓨터는 그렇게 작동하지 않는다
강의 초반에 설명해주신 이진수 표현법 때문에 요게 돌고 그 오버플로우 방식으로 돌아서 이런 숫자로 나오게 되는 것이다

굉장히 강조를 해주시는데, 나중에 정신없이 막 코딩하다 보면 이런 문제 만나게 될 가능성이 꽤 높다
적어도 한 두 번 쯤 만나게 될 것이다
그래서 이런 문제가 있을 수 있다는 것을 알고 있어야 한다

그 다음에 또 반대로 이런 문제가 있을 수 있다는 걸 이해하려면 내가 컴퓨터의 근본적인 구조 CPU, 메모리
메모리의 데이터 구조가 저장이 되는 구조 등을 점점 더 깊게 이해한다는 증거이기도 하다


---

## 2. Troubleshooting

> [!failure] 문제 상황 (Problem)

- 현상
	- float에서 f를 빼면 어떻게 되는지

- 에러 코드
	- `C4305` 'initilizating': tuncation from 'double' to 'float'


> [!search] 시도한 방법들 (Attempts)

```C++
#include <iostream>

int main()
{
	using namespace std;

	bool bValue = false;
	char chValue = 65;
	float fValue = 3.141592f;
	double dValue = 3.141592;

	int i = (int)3.1415; // copy initialization
	int a((int)3.14); // direct initialization 
	int b{ 4 }; // uniform initialization 

	int k = 0, l = (456), m = { 123 };

	return 0;
}
```

- float fValue = 3.141592f; 로 f를 붙여서 수정    


> [!success] 해결 및 원인 (Solution)

**이 리터럴은 double이다**
**컴파일러가 3.141592가 인식할때는 double이다 f가 안붙었기 때문이다**

근데 **Double은 Float보다 메모리를 두 배 쓴다** 더 정밀한 것이다
정밀한 것을 정밀도가 떨어지는 Float에다 저장을 하려니까 잘려나가는 부분이 있을 것이다

 truncation, truncate 이게 길면 긴 부분 자른다는 이야기이다, 절삭된다는 의미

그러니 정밀도가 더 높은걸 더 작은 것에다 억지로 스쳐 넣었으니 잘려 나간 부분이 있을 것이다
그러니 감수해라 라고 경고를 해주는 것이다


---

## 3. Optimization & Analysis (심화)

#### 부동소수점

```C++
#include <iostream>
#include <iomanip>
#include <limits>

int main()
{
	using namespace std;

	double zero = 0.0;
	double posinf = 5.0 / zero;
	double neginf = -5.0 / zero;
	double nan = zero / zero;

	cout << posinf << " " << std::isinf(posinf) << endl;
	cout << neginf << " " << std::isinf(neginf) << endl;
	cout << nan << " " << std::isnan(nan) << endl;
	cout << 1.0 << " " << std::isnan(1.0) << endl;

	return 0;
}
```

오늘 사실 부동소수점도 했는데
무슨 말인지 솔직히 이해가 잘 안간다..

오늘 배웠던 내용은 계속 복습을 좀 해야 할 것 같다

#### 정리

오늘 내용은 복습해서 체화시킬 시간이 많이 필요할 것 같다
뭔가 알 것 같은데 깊게는 이해하지 못한 개념들이 너무 많다

필사해가면서 다시 습득할 수 있도록 하자


---

## 4. References

- [https://en.cppreference.com/w/cpp/numeric/math/isnan.html



---

## 5. Tomorrow's Plan

- [ ] 대학원 연구성과 발표, 세미나, 워크숍 참여 예정

