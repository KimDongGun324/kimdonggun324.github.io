




# TIL 2025_12_18


## 1. Today I Learned (핵심 개념)

## 1. 기본 자료형 소개_Fundamental Data Types


```C++
#include <iostream>

int main()
{
	using namespace std;

	bool bValue = false;
	char chValue = 65;
	float fValue = 3.141592f;
	double dValue = 3.141592;

	int i = (int)3.1415; // copy initialization
	int a((int)3.14); // direct initialization 
	int b{ 4 }; // uniform initialization 

	int k = 0, l = (456), m = { 123 };

	return 0;
}


// cout << (bValue ? 1 : 0) << endl;  

// cout << sizeof(aValue) << endl;
// cout << sizeof(aValue2) << endl;

// cout << sizeof(bValue) << endl;
// cout << sizeof(bool) << endl;

// auto aValue = 3.141592;
// auto aValue2 = 3.141592f;

```

#### Character types

문자 하나를 저장하는 타입

wchar은 윈도우와 리눅스와 왔다 갔다 하는 경우에 골치 아프게 나타나는 경우가 있다
특히 Windows API로 프로그래밍 했을 경우 많이 보게 되는데 최근에는 많이 사라지고 있는 경향이다
많이 쓰진 않지만 이런게 있나 보다 하고 넘어가면 된다
문자를 저장하는 방식 자체가 다른 것들과 조금 다르다
잘못하면 문제가 생길 수도 있다는 것을 알아두면 좋음

#### Integer types

문자 여러 개를 저장하는 것, 문장을 저장하는 것, 단어나 문장 등 메모리를 길게 잡아야 할 때 문자 열을 저장하는 타입

최근 C++에서는 string을 많이 사용한다
string은 fundamental data type은 아니다 근데 사람들이 많이 쓰기 떄문에 표준처럼 마치 기본 데이터 타입인 것처럼 사용되는 경향이 있다
String은 표준 라이브러리라고 일단 알아두자


> [!NOTE] 참고
> Signed int는 음의 정수, 0, 양의 정수(자연수)를, unsigned int는 양의 정수와 0을 포함한다
> 수학 용어에서 '양의 정수(positive integer)'나 '음의 정수(negative integer)'는 0을 포함하지 않음


###### Signed

음수가 가능한 데이터 타입은 signed
음의 정수, 영, 양의 정수 자연수 등을 말함


###### Unsigned

0은 가능한데 음의 정수는 불가능하다


###### Q. 왜 이 차이를 두는것인가?

Singed와 Unsigned하고 저장되는 방식이 다르다
그래서 나중에 for 반복문 이런거 할 때 unsigned가 특정 연산을 할 때는 더 빠른 경우가 있다
똑같이 일을 더 하는데 unsigned가 signed보다 더 빠르다던지, 빼기를 할 때 더 빠르다던지 이런 특징이 있어서 unsigned를 구분했다

즉, 둘 다 정수 타입인데 Signed와 Unsigned는 다르다

그러면 다음과 같이 나온다
이거는 cout에서 자리수를 맞춰줘서 이렇게 나오게 된다

내부적으로는 3.141592를 가장 정확하게 표현할 수 있는 이진수 표현법
이진수로 실수를 표현하는 법으로 바꿔서 저장을 하고 있다

 여기서 중요한건 수학적으로 접근하는 것만큼 정밀하지 않다
 굉장히 큰 오류가 발생할 수 있기 때문이다

#### Q. float에서 f를 빼면 어떻게 되는지?


이 리터럴은 double이다
컴파일러가 3.141592가 인식할때는 double이다 f가 안붙었기 때문이다

근데 Double은 Float보다 메모리를 두 배 쓴다 더 정밀한 것이다
정밀한 것을 정밀도가 떨어지는 Float에다 저장을 하려니까 잘려나가는 부분이 있을 것이다

 truncation, truncate 이게 길면 긴 부분 자른다는 이야기이다, 절삭된다는 의미

그러니 정밀도가 더 높은걸 더 작은 것에다 억지로 스쳐 넣었으니 잘려 나간 부분이 있을 것이다
그러니 감수해라 라고 경고를 해주는 것이다


#### auto value

자동으로 float인지 double인지 구별해서 출력해주는 방식



---


## 2. 정수형 (Integers)


```c++
#include <iostream>
#include <cmath>
#include <limits>

int main()
{
	using namespace std;

	// int i = 22 / 4;

	cout << 22 / (float)4 << endl;

	return 0;
}


// int		i = 1;
// long	l = 1;
// long long ll = 1;

// cout << sizeof(int) << endl;
// cout << sizeof(long) << endl;
// cout << sizeof(long long) << endl;



	// short	s = 1; // 2 bytes = 2 * 8 bits = 16 bits

	//cout << std::pow(2, sizeof(short) * 8 - 1) - 1 << endl;
	//cout << std::numeric_limits<short>::max() << endl;
	//cout << std::numeric_limits<short>::min() << endl;
	//cout << std::numeric_limits<short>::lowest() << endl;

	//s = std::numeric_limits<short>::min();

	//cout << "min() " << s << endl;

	//s = s - 1; 

	//cout << " " << s << endl; // overflow 



	//unsigned int i = -1;

	//cout << i << endl;

```

#### 오버플로우

이게 무슨 현상이냐면 32768이 지금 표현할 수 있는 가장 큰 숫자였다
그래서 2를더하면 그 이진수로 표현을 할 때 표현을 해놓고 2를 더해버리면 뒤로 돌아가버린다
그래서 오히려 더 작은 수가 되어버린 것이다

내생각 : 아 그니까 32768에서 뒤로 가버리니까 -32768이 나오는 논리인 것 같다

그러면 이번에는 가장 작은 숫자에서 1을 빼보자

```C++
#include <iostream>
#include <cmath>
#include <limits>

int main()
{
	using namespace std;

	short	s = 1; // 2 bytes = 2 * 8 bits = 16 bits

	//cout << std::pow(2, sizeof(short) * 8 - 1) - 1 << endl;
	//cout << std::numeric_limits<short>::max() << endl;
	//cout << std::numeric_limits<short>::min() << endl;
	//cout << std::numeric_limits<short>::lowest() << endl;

	s = std::numeric_limits<short>::min();

	cout << "min() " << s << endl;

	s = s - 1; 

	cout << " " << s << endl; // overflow 

	return 0;
}
```

이렇게 수정했다
이렇게 되면 s에 출력이 되는 것은 Min 값일 것이다
short data type이 표현할 수 있는 가장 작은 숫자일 것이다

s에 뭐가 나오는지 확인해보자

```
min() -32768
 32767
```

이렇게 나왔다

-32768에서 -1을 하면 -32769가 나와야 하는데, 32767이 나왔다

다시 이제 돌아가버린 것이다
뱀 두마리가 서로 꼬리를 물고 있는 그런 느낌인 셈이다

이게 굉장히 중요한 문제이다
의외로 많이 만나게 되는 문제이다

오버플로우라고 부르고, 아주 흔하다

