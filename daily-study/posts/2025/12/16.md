




TIL 2025_12_16

## 1. Today I Learned (핵심 개념)

## 주제 1. 선언과 정의의 분리

#### 개념
forward declaration(전방 선언)
definition(정의)

컴파일러는 위에서 아래로 훝으며 읽는다
근데, 함수를 상단에서 선언하지 않으면 에러가 난다
그래서 main 함수 위에 다음과 같이 함수를 미리 선언해두면 에러가 나지 않는다


```c++
#include <iostream>

using namespace std;

int add(int a, int b); // forward declaration
int multiply(int a, int b);
int subtract(int a, int b);

int main()
{
	cout << add(1, 2) << endl;
	cout << subtract(1, 2) << endl;

	return 0;
}

//defintion
int add(int a, int b)
{
	return a + b;
}

int multiply(int a, int b)
{
	return a * b;
}

int subtract(int a, int b)
{
	return a - b;
}

```
## 주제 2. 헤더 파일 만들기

#### 개념

```c++
#include <iostream>

using namespace std;

int add(int a, int b);

int main()
{
	cout << add(1, 2) << endl;

	return 0;
}

// 아래 함수를 위와 같이 수정함

#include <iostream>

using namespace std;

int add(int a, int b)
{
	return a + b;
}

int main()
{
	cout << add(1, 2) << endl;
}
```

여기서, 프로토 타입 함수를 항상 복사 붙여넣기 하는 것도 사실 번거롭다
내가 파일을 분리한 이유는 재사용하려고 그런 것이다

같은 함수가 너무 커서 다른 데로 옮겨 놓은 것도 있지만 대부분의 경우는 또 한번 쪼개놓은 것은 다른 곳에서 다시 사용을 할 것이다

다른 함수에서 add 함수를 사용하고 싶을 때가 있는데 그때마다 이렇게 declaration 매번 선언해주기가 굉장히 번거롭다
그래서 헤더 파일을 만든다

#### Q. 왜 iostream은 <>이고, add.h는 ""인 것인지?

단순하다
iostream은 특별한거라서 그렇다
표준에 들어있는 컴파일러와 같이 딸려오는 것이라 특별처리해주는 것이다

## 3. 헤더 가드가 필요한 이유

#### 개념

```C++
//#pragma once

int add(int a, int b)
{
	return a + b;
}
```

일단 헤더파일에 이렇게 넣었는데 여기서 궁금증이 생긴다

왜 바디까지 다 넣었나?
본래는 add.cpp파일을 생성해서 거기에 바디를 넣지 않냐 라고 하는데,

본래는 그렇게 하는 것이 좋다
그리고 그게 맞다고 교수님이 하시는데, 보통 바쁘고 정리하기가 복잡해서 프로그래머들이 신경을 못쓰기 때문에 이렇게 넣는 경우가 많다고 한다
그래서 문제가 생긴다고 하신다

근데, 여기서 이 헤더 가드라는 걸 사용하면 여기에 바디까지 다 있어도 문제가 안 생긴다
그래서 쓰는 것이다


<>를 쓰는 이유도 표준적으로 사용되는 것이고, 또 iostream.h 파일이 있는 위치가 달라서 그렇다
파일 위치가 add.h와는 다르다

#### pragma once

```C++
#pragma once

//#ifndef MY_ADD
//#define MY_ADD

int add(int a, int b)
{
	return a + b;
}

//#endif
```

보통 이게 표준인데 일단 주석처리 해둠
근데 pragma once를 쓰면 앞서 저런 것들 적지 않아도 제대로 작동하게 된다
그래서 비주얼 스튜디오의 헤더 파일은 저거 다 넣는다고 생각하면 편하다

## 4. 네임 스페이스 (명칭 공간)

```C++
#include <iostream>

namespace Myspace1
{ 
	namespace Innerspace
	{
		int my_function()
		{
			return 0;
		}
	}
	int doSomething(int a, int b)
	{
		return a + b;
	}
}

namespace Myspace2
{
	int doSomething(int a, int b)
	{
		return a * b;
	}
}
using namespace std;

int main()
{
	using namespace Myspace1::Innerspace;

	my_function();

	//cout << Myspace1::doSomething(3, 4) << endl;
	//cout << Myspace2::doSomething(3, 4) << endl;

	return 0;
}
```

개념 자체는 어렵지 않다
중복되는 함수 이름을 namespace로 분리해주는 것이다

교수님께서, 같은 이름의 함수가 있는데, 물론 이름을 바꾸면 더 쉽지만 바꾸기 애매한 경우도 있다고 했다
그럴 땐 namespace로 다음과 같이 분리시켜주면 된다고 하셨다

## 5. 전처리기와의 첫 만남

```C++
// Chapter1_14.cpp : Defines the entry point for the console application.
//

#include <iostream>
using namespace std;

#define LIKE_APPLE

void doSomething();

int main()
{
	doSomething();

	return 0;
}



#include <iostream>

void doSomething()
{
	using namespace std;

#ifdef LIKE_APPLE
	cout << "Apple" << endl;
#endif

#ifndef LIKE_APPLE 
	cout << "Orange" << endl;
#endif

} 

```

보통 매크로라고도 하는데 매크로는 거의 대문자로 쓴다

ifdef, ifndef, endif 이것들은 전처리기이다
전처리기라는 것은 빌드 들어가기 전에 한다는 의미이다
그래서 빌드 할 때 이것들이 완전히 결정이 되어버린다

 언제 많이 쓰냐면은 이 프로그램이 지금 빌드를 시작하는데 빌드 시작하기 전에
 윈도우즈인지 리눅스인지 좀 알고 시작하자 보통 이럴 때 많이 시작한다

좀 더 나간다면 그래픽카드 사양 OpenGL을 쓸지 Direct X를 쓸지 등
지금은 많이 사용하진 않을 것이다

근데 만약 멀티플랫폼 소프트웨어를 개발한다
그럼 그때 이걸 정신없이 쓰게 될 것이다

#### Q. Like Apple 뒤에는 왜 빈칸인지?

define은 뭔가로 교체해주는 전처리기인데 왜 지금 LIKE_APPLE 뒤에는 빈칸인가?

지금 보면 뒤에 아무것도 없으니 int main 밑에 LIKE_APPLE을 빈칸으로 교체되는건 아닌가?
라고 생각할 수도 있다

근데 define이 뒷부분과 교체를 해주는 것은 맞는데, 매크로 안에서는 그렇게 안한다

ifdef, ifndef, endif else 이것들은 다 전처리기이다
매크로 안의 전처리기 라인 안에서는 교체를 안한다
기억 해두면 나중에 도움이 많이 된다

---

## 2. Troubleshooting

> [!failure] 문제 상황 (Problem)
> 
> - 헤더가 두번 가져와지는 문제가 발생
> 
>   
>     


> [!search] 시도한 방법들 (Attempts)
> 
> 1. #include "add.h" 제거 -> 이 방법 아님
>     
> 2. pragma one 전처리기 제대로 입력되었는지 확인
>     
> 3. int add, void doSomething 함수 삭제
>    -> 왜냐면 include 되어 있기 때문
>
> 

> [!success] 해결 및 원인 (Solution)
> 
> - **원인:** 직접적으로 add.h를 한번 include 해서 또 한번 add가 두 번 들어오고 두 번 정의가 되니까 빌드가 안되는 문제가 발생


#### 해결

```C++
#include <iostream>
#include "mywork.h"
#include "add.h"

using namespace std;

int main()
{
	doSomething();

	return 0;
}


#### 배운점

헤더의 작동 방식에 대해 다시 생각해볼 수 있었다
사실 너무 당연한 논리였음

mywork.h안에 add 함수가 include 되어 있다

mywork.h안에는 dosomething 함수가 있으니
int main 에 doSomething();만 선언해줘도 자연스레 add도 딸려오게 되는 구조니
add 함수가 두번 include 되지 않고 깔끔하게 한번만 include 되어서 빌드가 잘 되게 된다

```C++
#pragma once

#ifndef MY_ADD
#define My_ADD

int add(int a, int b)
{
	return a + b;
}

#endif

```

이게 표준인데 번거로운 부분이 있어서 pragma once를 쓴다
비주얼스튜디오의 헤더 파일은 저거 다 넣는다고 생각하면 편하다

## 4. References

-  [홍정모 교수님의 따라배우는 C++](https://www.inflearn.com/course/following-c-plus/dashboard)

---

## 5. Tomorrow's Plan

- [ ] (논문 작성 마무리)

