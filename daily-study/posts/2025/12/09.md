
---

# TIL 2025-12-09

> 오늘의 목표
> - [x] C++ 기초 문법(함수, 식별자, 스코프, 연산자)을 학습하고 메모리 동작 원리 이해하기
> 
> - [x] 리터럴 접미사(`f`) 사용의 중요성과 그래픽스 최적화와의 연관성 파악하기


---

## 1. Today I Learned (핵심 개념)

#### 주제 1: 지역 범위(Local Scope)와 스택 메모리

- **개념**
    - 중괄호 `{}`는 변수의 생명 주기(Scope)를 결정한다.
        
    - 영역 내에서 선언된 변수는 영역을 벗어나는 순간 메모리에서 반납된다.

- **Why? (중요)**
    - 지역 변수는 **스택(Stack) 메모리**에 저장된다. 스코프가 종료되면 스택 포인터가 이동하며 자동으로 메모리가 해제되므로, 불필요한 메모리 점유를 막기 위해 변수의 선언 위치와 범위를 신중히 결정해야 한다.

###### Code Snippet:
```c++
{
    int x = 1; // 스택 메모리 할당
    {
        int x = 2; // 위 x와 다른 주소(식별자 중복 가능하지만 권장 X)
        cout << x << endl; // 2 출력
    } // 내부 x 소멸 (메모리 반납)
    cout << x << endl; // 1 출력
} // 외부 x 소멸
```

#### 주제 2: 리터럴(Literal)과 접미사

- **개념**
    - 소스 코드에 고정된 값 자체를 의미한다. 접미사에 따라 데이터 타입(메모리 크기)이 결정된다.
        
    - 정수(`u`, `L`), 실수(`f`), 16진수(`0x`) 등.

- **Why?**
    - **최적화 관점:** C++에서 `3.14`는 기본적으로 8바이트 `double`이다. 이를 `float` 변수에 담으면 형 변환 비용이 발생한다. 그래픽스 연산(HLSL 등)은 주로 4바이트 `float`를 사용하므로 `f` 접미사를 붙이는 습관이 필수적이다.

###### Code Snippet:
```C++
float a = 3.14;  // double(8byte) -> float(4byte) 암시적 형 변환 발생 (비효율)
float b = 3.14f; // float(4byte)로 바로 초기화 (효율적)
int color = 0xFF0000; // 16진수 리터럴 (Red Color)
```

#### 주제 3: 함수(Function)와 디버깅

**개념**

- 반복되는 코드를 모듈화하여 재사용성을 높인다. 매개변수(Parameter)는 함수 정의부의 변수, 인수(Argument)는 실제 전달되는 값이다.
    
- `Step Into (F11)`를 통해 함수 내부의 메모리 흐름을 추적할 수 있다.


---

## 2. Troubleshooting

> [!failure] 문제 상황 (Problem)
> 
> - **현상:** `void` 반환 타입인 함수에서 값을 return 하려고 시도함. 또는 지역 변수의 범위 착각으로 인한 "선언되지 않은 식별자" 오류 예상.
>     
> - **에러 코드:** `E0127` (void 함수는 값을 반환할 수 없음) 또는 `C2065` (선언되지 않은 식별자)
>     

> [!search] 시도한 방법들 (Attempts)
> 
> 1. 함수의 반환 타입(`int`, `void`)을 확인.
>     
> 2. `return;` (값 없이 종료)과 `return x;`의 차이 구분.
>     
> 3. 변수가 선언된 중괄호 `{}`의 위치 확인 (Scope Check).
>     

> [!success] 해결 및 원인 (Solution)
> 
> - **원인:** `void` 함수는 리턴값이 없어야 하는데 `return x + y;` 형태로 작성함.
>     
> - **해결:** - 함수 정의부의 `void`를 `int`로 수정하거나, 반환문을 제거함.
>     
> - **배운 점:** 함수의 선언부(Signature)와 구현부의 반환 규칙은 엄격하게 일치해야 한다. 또한 변수는 선언된 `{}` 블록 밖에서는 접근할 수 없다(메모리에서 사라짐).
>     

---

## 3. Optimization & Analysis (심화)

- **Topic:** 실수 리터럴의 데이터 타입 미스매치 방지
    
- **Before:**
    
    - `float pi = 3.14;`
        
    - 컴파일러가 `3.14(double)`를 임시 생성 후 `float`로 캐스팅하여 저장.
        
    - 미세하지만 불필요한 CPU 연산 및 정밀도 손실 가능성 존재.

- **After:**
    
    - `float pi = 3.14f;`
        
    - 컴파일 시점에 `float` 타입으로 리터럴이 해석됨.
        
    - **HLSL/GLSL 셰이더 코딩 시:** 대부분 `float` 연산이므로 C++ 단계에서부터 습관을 들이는 것이 중요함.

- **Visualization:**
    
    - (메모리 관점) `Double(8 bytes)` → [Truncation] → `Float(4 bytes)` 과정을 생략하고 즉시 `Float` 할당.


---

## 4. References

- https://en.cppreference.com/w/cpp/keyword.html
    
- 홍정모의 따라하며 배우는 C++ (섹션 1-5 ~ 1-9)

---

## 5. Tomorrow's Plan

- [ ] 내일은 논문 작성 하기
    
- [ ] 오늘 배운 내용 복습

---

https://donggun-kim.tistory.com/3
